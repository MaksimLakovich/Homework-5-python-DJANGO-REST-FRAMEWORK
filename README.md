# LMS API (Django REST Framework)


[1. Цель проекта](#title1) / 
[2. Модели](#title2) / 
[3. Админки](#title3) / 
[4. Сериализации](#title4) / 
[5. Валидация](#title5) / 
[6. Контроллеры](#title6) / 
[7. Права доступов](#title7) / 
[8. Вспомогательные функции](#title8) / 
[9. Загрузка тестовых данных](#title9) / 
[10. Установка проекта](#title10) / 
[11. Получение ключей .env](#title11) / 
[12. Описание файла .flake8](#title12) / 
[13. Описание файла mypy.ini](#title13) / 




# <a id="title1">1. Цель проекта</a>
Backend для разработки LMS-системы (онлайн-платформы обучения), в которой каждый желающий сможет размещать свои полезные материалы или курсы.
Разработка выполнена над SPA веб-приложением и результатом создания проекта будет бэкенд-сервер, который возвращает клиенту JSON-структуры.




# <a id="title2">2. Описание моделей (models)</a>

## _Приложение "Users" (users/models.py):_

1) Модель данных `CustomUser(AbstractUser)` - представляет Пользователя на платформе для онлайн-обучения (авторизация по email):
   - Наследуется от модели **AbstractUser**, которая является готовой моделью и включает все основные поля и методы, такие как username, email, first_name, last_name, is_staff, is_active и другие.
   - ***Дополнительно определил:***
     - ник пользователя (username);
     - эл.почта пользователя (email);
     - телефон пользователя (phone_number);
     - город пользователя (city);
     - аватар пользователя (avatar).

2) Модель данных `Payments(models.Model)`- представляет платежи за Lesson и/или за Course на платформе для онлайн-обучения:
   - пользователь (user).
   - дата и время оплаты (payment_date).
   - оплаченный курс (paid_course).
   - оплаченный урок (paid_lesson).
   - сумма платежа (payment_amount).
   - метод платежа (payment_method).

## _Приложение "lms_system" (lms_system/models.py):_

1) Модель данных `Course(models.Model)` - представляет Курс на платформе для онлайн-обучения:
   - название курса (title).
   - превью курса (preview).
   - описание курса (description).
   - владелец курса (owner).

2) Модель данных `Lesson(models.Model)` - представляет Урок на платформе для онлайн-обучения:
   - курс урока (course).
   - название урока (title).
   - описание урока (description).
   - превью урока (preview).
   - ссылка на видео урока (video_url).
   - владелец урока (owner).

3) Модель данных `Subscription(models.Model)` - представляет Подписку на обновление курса (Course) для пользователя (CustomUser):
   - курс на который подписка (course).
   - подписчик (user).




# <a id="title3">3. Описание админок (admin)</a>

## _Приложение "Users" (users/admin.py):_

1) Админка `CustomUserAdmin(UserAdmin)` - отображение данный модели Пользователя (CustomUser) в админке.

## _Приложение "lms_system" (lms_system/admin.py):_

1) Админка `CourseAdmin(admin.ModelAdmin)` - отображение данных модели Курса (Course) в админке.

2) Админка `LessonAdmin(admin.ModelAdmin)` - отображение данных модели Урока (Lesson) в админке.

3) Админка `SubscriptionAdmin(admin.ModelAdmin)` - отображение данных модели Подписки (Subscription) в админке.




# <a id="title4">4. Описание сериализаций (serializers)</a>

## _Приложение "Users" (users/serializers.py):_

1) Сериализатор `CustomUserSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели CustomUser. Описывает то, какие поля модели CustomUser будут участвовать в сериализации и десериализации.
   - Кастомизация сериализатора:
     - поле `payments` - с помощью сериализатора для связанной модели *Payments* (**PaymentsSerializer(many=True, read_only=True)**) вывод детальной информации по всем платежам пользователя, где:
       - ***many=True*** - параметр указывает, что это поле является связью "один ко многим" и может содержать несколько записей.
       - ***read_only=True*** - параметр указывает, что поле только для чтения и НЕ будет ожидаться на входе в запросах POST/PUT.
     - `to_representation(instance)` - возвращает сериализованное представление пользователя.
       - Если запрашивающий пользователь смотрит "свой профиль", то отображаются все поля.
       - Если запрашивающий пользователь смотрит "чужой профиль", то скрываются конфиденциальные поля:
         - last_name (фамилия)
         - payments (история платежей)
         - password (в любом случае не нужен в ответе)
       - Используется для динамической настройки отображения данных в зависимости от прав доступа.
   - Дополнительные параметры Meta-класса:
     - параметр `extra_kwargs` - зарезервированное имя параметра в Meta-классе ModelSerializer для настройки конкретных полей, например, ниже указываю что пароль только на ЗАПИСЬ. Т.е. его можно отправить через POST/PUT/PATCH, но он не будет отображаться в ответе API (GET, LIST и т.п.).
     ```python
     extra_kwargs = {
        "password": {"write_only": True},
     }
     ```

2) Сериализатор `PaymentsSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Payments. Описывает то, какие поля модели Payments будут участвовать в сериализации и десериализации.

3) Сериализатор `CustomObtainPairSerializer(TokenObtainPairSerializer)` - кастомный класс-сериализатор токена наследующийся от TokenObtainPairSerializer, позволяющий вход по email.
   - Кастомизация сериализатора:
     - функция `def validate(self, attrs)` - позволяет принять email вместо username, найти пользователя по email, проверить пароль и вернуть токены.

## _Приложение "lms_system" (lms_system/serializers.py):_

1) Сериализатор `CourseSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Course. Описывает то, какие поля модели Course будут участвовать в сериализации и десериализации.
   - Кастомизация сериализатора:
     - функция `get_count_lessons()` - определение количества уроков в курсе (запрос в БД для подсчёта связанных уроков). Учитываю кастомный ***related_name="lessons"*** в модели Lesson.
     - функция `get_is_subscribed()` - пороверяет подписан ли текущий пользователь на данный курс (True / False).
     - поле `lessons` - с помощью сериализатора для связанной модели *Lesson* (**LessonSerializer(many=True, read_only=True)**) вывод детальной информации по всем урокам курса, где:
       - ***many=True*** - параметр указывает, что это поле является связью "один ко многим" и может содержать несколько записей.
       - ***read_only=True*** - параметр указывает, что поле только для чтения и НЕ будет ожидаться на входе в запросах POST/PUT.
   - Валидация в сериализаторе:
     - для поля `description` определен валидатор `validators=[validate_domain_links]`.

2) Сериализатор `LessonSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Lesson. Описывает то, какие поля модели Lesson будут участвовать в сериализации и десериализации.
   - Валидация в сериализаторе:
     - для полей `video_url` и `description` определен валидатор `validators = [YoutubeDomainValidator(fields=["video_url", "description"])` - реализовано так, чтоб мы в **class Meta** у сериализатора LessonSerializer могли в валидатор передавать сразу несколько полей которые нужно валидировать.




# <a id="title5">5. Описание валидации (validators)</a>

## _Приложение "lms_system" (lms_system/validators.py):_

1) Класс-валидатор `YoutubeDomainValidator` - для проверки допустимости домена в передаваемых пользователями URL. Разрешает только ссылки на YouTube (youtube.com и www.youtube.com).
   - Можно применять к различным типам полей (к URLField, к CharField, к TextField), что делает валидатор универсальным.
   - Используется регулярное выражение (***url_pattern = re.compile(r"https?://[^\s]+")***), что дает возможность поиска всех вхождений URL (http:// или https://) в передаваемом пользователе поле.

2) Функция-валидатор `validate_domain_links(field)` - для проверки допустимости домена в передаваемых пользователями URL. Разрешает только ссылки на YouTube (youtube.com и www.youtube.com).
   - Можно применять к различным типам полей (к URLField, к CharField, к TextField), что делает валидатор универсальным.
   - Используется регулярное выражение (***url_pattern = re.compile(r"https?://[^\s]+")***), что дает возможность поиска всех вхождений URL (http:// или https://) в передаваемом пользователе поле.




# <a id="title6">6. Описание контроллеров (views)</a>

## _Приложение "Users" (users/views.py):_

1) Класс-контроллер `CustomUserListAPIView(generics.ListAPIView)` - получение списка зарегистрированных пользователей.
   - на основе ***Generic*** - это компонент Django REST framework, который предоставляет набор готовых классов и миксинов для упрощения разработки RESTful API.
   - ***Доступно***: аутентифицированным пользователям.

2) Класс-контроллер `CustomUserCreateAPIView(generics.CreateAPIView)` - регистрация нового пользователя.
   - на основе ***Generic***.
   - ***Доступно***: всем пользователям.

3) Класс-контроллер `CustomUserRetrieveUpdateAPIView(generics.RetrieveUpdateAPIView)` - получение и редактирования профиля пользователя.
   - на основе ***Generic***.
   - ***Доступно***:
     - Просматривать профиль пользователя может любой авторизованный пользователь (только без персональных данных).
     - Редактировать профиль пользователя может только сам пользователь.
   - Кастомизация контроллера:
     - `get_serializer_context()` - передаёт request в сериализатор для дальнейшего анализа (например, в to_representation).
     - `check_object_permissions()` - проверяет права доступа к редактированию профиля.
       - ***Доступно***:
         - Просматривать (GET) может любой авторизованный пользователь.
         - Редактировать (PUT, PATCH) может только владелец профиля.

4) Класс-контроллер `CustomUserDestroyAPIView(generics.DestroyAPIView)` - удаление пользователя.
   - на основе ***Generic***.

5) Класс-контроллер `CustomTokenObtainPairView(TokenObtainPairView)` - класс-контроллер на основе TokenObtainPairView для возможности авторизации по email, так как я убрал username, которое было по умолчанию в DRF.
   - на основе ***TokenObtainPairView*** - базовый класс для получения JWT-токена.

6) Класс-контроллер `PaymentsListCreateAPIView(generics.ListCreateAPIView)` - получение списка платежей и создания нового платежа.
   - на основе ***Generic***.

7) Класс-контроллер `PaymentsRetrieveUpdateDestroyAPIView(generics.RetrieveUpdateDestroyAPIView)` - получение, обновление и удаление одного платежа.
   - на основе ***Generic***.

## _Приложение "lms_system" (lms_system/views.py):_

1) Класс-контроллер `CourseViewSet(viewsets.ModelViewSet)` - автоматический CRUD для модели Course на основе ModelViewSet.
   - на основе ***ModelViewSet*** - это компонент Django REST для эффективного управления API-ресурсами и уменьшения объема кода.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям с курсами в зависимости от типа запроса (action).
       - **create / list**:
         - Доступ разрешён только администраторам (IsAdminUser) и аутентифицированным (IsAuthenticated).
         - Владелец курса назначается автоматически (self.request.user).
       - **retrieve / update / partial_update**:
         - Владелец курса (IsOwner) может просматривать и редактировать свои курсы.
         - Модератор (IsModerator) может просматривать и редактировать любые курсы.
       - **destroy**:
         - Только владелец курса может удалить свой курс.
         - Администратор (IsAdminUser) может удалять любые курсы.
     - `perform_create(serializer)` - определяет и фиксирует владельцем Пользователя, который создал данный объект.

2) Класс-контроллер `LessonListCreateAPIView(generics.ListCreateAPIView)` - получение списка уроков и создание нового урока.
   - на основе ***Generic***.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям со списком и созданием уроков:
        - **GET (список - List), POST (создание - Create)**:
          - Доступ разрешён только администраторам (IsAdminUser) и аутентифицированным (IsAuthenticated).
          - Владелец урока назначается автоматически (self.request.user).
     - `perform_create(serializer)` - определяет и фиксирует владельцем Пользователя, который создал данный объект.

3) Класс-контроллер `LessonRetrieveUpdateDestroyAPIView(generics.RetrieveUpdateDestroyAPIView)` - получение, обновление и удаление одного урока.
   - на основе ***Generic***.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям с конкретным уроком:
        - **GET (просмотр - Retrieve), PUT/PATCH (обновление - Update)**:
          - Владелец урока (IsOwner) может просматривать и редактировать свои уроки. 
          - Модератор (IsModerator) может просматривать и редактировать любые уроки.
        - **DELETE (удаление - Destroy)**:
          - Только владелец урока может удалить свой урок. 
          - Администратор (IsAdminUser) может удалять любые уроки.

4) Класс-контроллер `SubscriptionToggleAPIView(APIView)` - для установления подписки/отписки Пользователя на Курс:
   - на основе низкоуровневого ***APIView***.
   - Кастомизация класса:
     - `def post()` - метод для подписки/отписки Пользователя на Курс:
       - Получает пользователя из request.user (аутентифицированный пользователь).
       - Получает ID курса из request.data.
       - Проверяет, есть ли уже подписка на курс для этого пользователя.
         - если есть, то удаляет её (отписка).
         - если нет, то создаёт новую (подписка).




# <a id="title7">7. Описание прав доступов (permissions)</a>

## _Приложение "Users" (users/permissions.py):_

1) Класс `IsModerator(BasePermission)` - кастомный permission-класс, проверяющий, является ли пользователь модератором. Модераторы - это пользователи, которые входят в группу "Moderators". Им разрешается просматривать (GET) и редактировать (PUT, PATCH) объекты, но не создавать (POST) и не удалять (DELETE).
   - функция `has_permission()` - возвращает True, если пользователь аутентифицирован и состоит в группе "Moderators". Используется в контроллерах для ограничения доступа к операциям создания и удаления уроков/курсов.

2) Класс `IsOwner(BasePermission)` - кастомный permission-класс, проверяющий, является ли пользователь владельцем (owner). Им разрешается просматривать (GET), редактировать (PUT, PATCH) и удалять (DELETE) только свои объекты.
   - функция `has_permission()` - возвращает True, если пользователь является владельцем объекта. Используется в контроллерах для ограничения доступа к операциям с чужими уроками/курсами.




# <a id="title8">8. Вспомогательные функции</a>

## _Приложение "Users" (users/managers.py):_

1) Класс `CustomUserManager(BaseUserManager)` - кастомный менеджер для пользователя без поля username:
   - функция `create_user()` - создает и возвращает обычного пользователя.
   - функция `create_superuser()` - создает и возвращает суперпользователя.




# <a id="title9">9. Загрузка тестовых данных</a>

## _Директория проекта для различных данных (data/fixtures):_
1. Файл `courses.json` - фикстура с тестовыми данными для БД (таблица с данными курсов).
2. Файл `lessons.json` - фикстура с тестовыми данными для БД (таблица с данными уроков).
3. Файл `payments.json` - фикстура с тестовыми данными для БД (таблица с данными платежей).
4. Файл `groups.json` - фикстура с данными группы "Moderators" и добавления в нее набора прав доступов.

## _Приложение "lms_system" (lms_system/management/commands):_
1. `add_courses.py` - код кастомной команды по загрузке данных из `courses.json`.
2. `add_lessons.py` - код кастомной команды по загрузке данных из `lessons.json`.

## _Приложение "Users" (users/management/commands):_
1. `add_users.py` - код кастомной команды по cозданию тестовых пользователей через create_user().
2. `add_payments.py` - код кастомной команды по загрузке данных из `payments.json`.




# <a id="title10">10. Установка проекта</a>
1. Клонируйте репозиторий:
   ```
   git clone https://github.com/MaksimLakovich/Homework-5-python-DJANGO-REST-FRAMEWORK.git
   ```
2. Установите зависимости:
   ```
   poetry install
   ```
3. Заполните файл `.env` по примеру `.env.example`




# <a id="title11">11. Получение ключей. Описание файла .env.example</a> 
1. Создайте файл .env в корне проекта из копии подготовленного файла `.env.example`, в котором описаны названия всех переменных, необходимых для работы приложения.
2. Замените значения переменных реальными данными.
3. В модуле `settings.py` существует секретный ключ `SECRET_KEY`, который рекомендуется в целях безопасности хранить в тайне:
4. Файл .env должен содержать данные:
```dotenv
# Настройки секретного ключа проекта django в config/settings.py
#Django рекомендует в целях безопасности хранить секретный ключ, используемый в продакшене, в тайне!
SECRET_KEY_FOR_PROJECT=secret_key_here

# Настройки дебага.
# В settings.py дебаг должен быть описан так: DEBUG = True if os.getenv('DEBUG') == 'True' else False
DEBUG=

# Настройки БД проекта django в config/settings.py
DATABASE_NAME=
DATABASE_USER=
DATABASE_PASSWORD=
DATABASE_HOST=
DATABASE_PORT=
```




# <a id="title12">12. Описание файла .flake8</a> 
```angelscript
[flake8]
max-line-length = 119
ignore = E203, W503
exclude = .git, __pycache__, venv, .venv
```




# <a id="title13">13. Описание файла mypy.ini</a> 
```ini
# Настроил mypy для Django, указав путь к settings.py.
# Это нужно было чтоб убрать ошибки проверки mypy
# из-за того, что он не распознавал phonenumber_field,
# так как у phonenumber_field нет type stubs.
[mypy]
plugins = mypy_django_plugin.main

# Указываем настройки для плагина Django.
[mypy.plugins.django-stubs]
django_settings_module = config.settings

# Пробовал игнорировать phonenumber_field в mypy.ini,
# но это не сработало, и поэтому пришлось добавить
# в код (users/models.py) вот это "# type: ignore"
# на импорт PhoneNumberField, и ошибка исчезла.
[mypy-phonenumber_field.*]
ignore_missing_imports = True
```